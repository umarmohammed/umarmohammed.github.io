---
layout: post
title: .Net Core Refresh Tokens
date: 2018-10-20
comments: true
categories:
- Authentication
tags:
- auth
- dotnetcore
---

JWTs are short lived tokens; meaning they expire soon after being generated. Therefore a user has to continually reauthenicate themselves to maintain access to the server.  In this post we look at how to overcome this limitation using refresh tokens.

<!-- more -->
#### Posts in this series
- [A Brief Intro to JWTS (Part 1)]({{ site.baseurl }}{% link _posts/2018/2018-10-02-Quick-into-to-JWT.md %})
- [.Net Core Authentication with JWTs (Part 2)]({{ site.baseurl }}{% link _posts/2018/2018-10-13-Dotnetcore-auth-with-JWT.md %})
- .Net Core Refresh Tokens (This Post)

##### Versions used in this post
- .Net Core 2.1

## Disclaimer

Authentication is hard to do correctly. The consequences of making a mistake in your authentication logic are more profound than making mistakes in other areas. The security of your users is at stake! In other posts in this series we're simply using the authentication features provided to us by the frameworks (.Net Core and Angular). We have faith that security errors in these frameworks will be minimal. Any errors which do get picked up normally get rectified very quickly. 

However in this post we are implementing some of our own security logic. I'm not a security expert and the information I provide here is essentially rehashed content collated from other sources (books, online courses, other blogs, stackoverflow etc) in my own words. As such I would not use the code in this post in production. It most likely contains mistakes and oversights due to my limited knowledge. This post just serves as an insight into the inner workings of refesh tokens. When doing this for real I would use a third party solution such as [Auth0](https://auth0.com/) or [IdentityServer](http://identityserver.io/).

## The Problem

#### The Need for Short Lived Tokens

Let's start off a quick recap of how token authentication works.
1. The client sends some credentials to the server.
2. The server checks the credentials and issues the client with a JWT.
3. The client makes authenticated requests by sending the JWT in its ```Authorization``` header.

The JWT contains information about the user represented as a set of claims (e.g. roles of the user, department user belongs to etc). The server uses these claims to evaluate what the user is allowed to access. Once a user has a JWT there is no easy of invalidating it. So long as the JWT was generated by the server using the secret key, it is considered valid. This is problematic, consider the following scenarios:
- A user obtains a JWT which has a claim signifying that they are an admin. At some point after obtaining the token the user is removed from the admin role. However they still have access to resources on the server which should only be accessible by an admin.
- The JWT is somehow compromised and gets into the hands of a third party. The third party will be able to access all restricted resources that the user had access to.

These risks are alleviated by giving tokens an expiry time. This expiry time is checked by the server when validating the token. The validity time of the token should be short. The longer the token is valid for, the more you are exposed to the vulnerabilities described above.  

Recall the way we generated tokens in the [previous post]({{ site.baseurl }}{% link _posts/2018/2018-10-13-Dotnetcore-auth-with-JWT.md %}):
```csharp
var token = new JwtSecurityToken(
  issuer: _configuration["Tokens:Issuer"],
  audience: _configuration["Tokens:Audience"],
  signingCredentials: credentials,
  expires: DateTime.UtcNow.AddMinutes(30),
  claims: claims
);
```
We set the "expires" parameter in the ```JwtSecurityToken``` constructor which in turn sets the "exp" claim in the generated JWT (see [https://tools.ietf.org/html/rfc7519#section-4.1.4](https://tools.ietf.org/html/rfc7519#section-4.1.4) for more details). In the code example above we've set the token to expire 30 minutes after it was created. This expiry is checked by the server when validating the token meaning that the token will only be valid for 30 minutes.

#### Bad UX
In the process of (somewhat) solving the issues with JWTs by making them short lived, we've introduced a new one. Namely the user now needs to get a new JWT every 30 minutes by reauthenticating themselves. Imagine you are on a website, or on a mobile app, and every 30 minutes you need to re-enter your login details. This makes for a poor user experience. We overcome this limitation by using refresh tokens. 

## Refresh Tokens To The Rescue

#### What are Refresh tokens?
Refresh tokens provide a mechanism whereby a client can use short lived JWTs to make authenticated requests to the server. Once the JWT expires they simply exchange it for another without having to resend their authentication credentials. This works in the following way:
1. When the client first authenticates it receives a short lived JWT, and in addition, a long lived refresh token.
2. The client uses the JWT to access restricted resources on the server as before.
3. When the JWT expires the client sends the refresh token and expired JWT to the server to request a new JWT.
4. The server does some checks on the refresh token and the expired JWT, generates a new short lived JWT(with updated claims), and sends it back to the client.
5. The client makes authenticated requests with the new JWT.

#### How Do Refresh Tokens Work?
- Initial authentication generates refresh token and JWT
- Stores in a database
- Refresh tokens bound to user
- Endpoint for exchanging access token
- checks refresh tokenid, checks protected ticket, gets new claims, returns new ticket

## The code

#### Adding a database
may as well add user database

#### binding the user to refresh token

#### endpoints
- edit token endpoint to create refresh token (as well as currenly access tokens) and return it to user
- new endpoint checks refresh token and creates new access token (should use without validating time)

## Demonstrating the flow




